1. Что такое функция и как ее объявить?
Функии - это многократно используемые фрагменты программы. Они позволяют дать имя определенному блоку команд
с тем, чтобы в последствии запускать этот блок по указанному имени в любом месте
программы.

2. Как создать функцию?
Функция создается с помощью зарезервированного слова Def. После чего указывается имя функции, затем
открываются круглые скобки в которых указываются имена некоторых переменных и двоеточие в конце.

3. Как показать что созданная функция возвращает результат?
команда Return возвращает значение или же результат.

4. В чем разница между параметрами и аргументами функции?
Параметры - это переменные которые объявлены в определении функции. Которые будут переданы функции при ее вызове.
Аргументы - это значения которые передаются при ее вызове. Они заполняют места, обозначенные параметрами
в конце в определении функии.

5. Как рекурсивные функции работают в Python?
Рекурсивная функция - это функция, которая способна вызывать себя из себя же, но с иными значениями параметров.
   При этом есть требования для корректной работы рекурсивной функции:
   1) базовый случай
      Обязательно необходимо задать четкое стоп-условие, которое остановит процесс
      и не даст ему выполняться бесконечно
   2) рекурсия
      Чтобы базовый случай в принципе состоялся, требуется передача измененных данных каждой новой вызванной функции

Например:
def summa(n):
    if n == 1:
        return 1
    else:
        return n + summa(n-1)

summa(5)

6. Что такое декораторы функций и как они используются? ( привести свой пример декоратора)
Декоратор - это функция, которая позволяет обернуть другую функцию для
расширения её функциональности без непосредственного изменения её
кода.
пример:
def timer(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Время выполнения функции {func.__name__}: {end_time - start_time} сек.")
        return result
    return wrapper

@timer
def some_function():
    time.sleep(2)

some_function()

7.Как расшифровывается ООП?
Объектно ориентированное программирование

8. Что относится к основным принципам(парадигмам) ООП?
инкапсуляция
наследование
полиморфизм

9. Что будет результатом программы и почему?
class Test:
    test = None


print(Test.test)
Результатом будет - None. Так как мы создали атрибут test в класск Test и передали ему значение в виде None.

10. Какой принцип ООП описывает следующее предложение?
Этот принцип является способностью использовать общий интерфейс для нескольких форм (типов данных).
Полиморфизм

11. Какой из перечисленных вариантов является верным объявлением private поля?
private field = 0
field = 0
_field = 0
__field = 0 - Правильный ответ

12. Как создать конструктор класса?
С помощью метода def __init__(self)

13. Как много конструкторов в классе может иметь Python?
В одном классе может быть неограниченное количество конструкторов.

14. Что будет результатом данной программы
class Test:
     def print_text(self):
         print('Это родительский класс Test')

class Test2(Test):
     def print_text(self):
         print('Это класс потомок Test2')


test = Test2()
test.print_text()

    Результат: Это класс потомок Test2

15.Какой параметр обязательно принимает в себя метод экземпляра?
тип объекта
сам экземпляр класса - Правильный ответ
название класса
таких аргументов нет

16. Как использовать инкапсуляцию для защиты данных в классах?
 Инкапсуляцию применяют в названии переменной.
    Есть 3 способа использования инкапсуляции:
    публичный (public, нет особого синтаксиса, public)
    защищенный (protected, одно нижнее подчеркивание в начале названия, _protected)
    приватный (private, два нижних подчеркивания в начала названия, __private)

17. 17) Какая разница между абстрактными классами и интерфейсами в Python?
Абстрактный класс может иметь как абстрактные, так и неабстрактные методы.
Он представляет собой шаблон или чертёж для создания других классов.

Интерфейс содержит только абстрактные методы.
Он определяет общее поведение группы классов, возможно, не связанных между собой.

18. Как показать в классе что метод является абстрактым?
Чтобы показать в классе, что метод является абстрактным,
используется аннотация @abstractmethod.

19. Что будет результатом программы?
class Test:
     __test = 0


print(Test.__test)
Результат: Ошибка, так как переменная является приватной

20. Что делает финализатор класса?
Финализатор для конкретного объекта всегда выполняется после того,
как программа прекращает использовать данный объект и до того, как занимаемая объектом память будет
освобождена сборщиком мусора.

21. Распишите работу магических методов: new, call
 __new__(cls[, ...]) — метод создания типа класса. Он принимает первым аргументом тип класса,
    в котором он вызывается, и, как правило, возвращает этот же тип. В основном используется,
    чтобы настраивать создание экземпляра класса тех объектов,
    которые наследуются от неизменяемых типов (например, int, str, или tuple)

    Метод __call__ позволяет создавать вызываемый объект, а не функцию. Характеризуя метод __call__ внутри класса,
    создаются вхождения этого класса, которые будут выполнять аналогичные функции при вызове.
    Этот метод обычно вызывается, когда объект вызывается внутри события, в котором он был функцией.

22. Если в классе определены два метода с одинаковыми именами и разными списками параметров, что будет результатом?

Если в классе есть два метода с одинаковыми именами‚ то второе определение полностью заменит первое.
При вызове этого метода будет использоваться второе определение с соответствующими параметрами.

23. Значением поля класса по умолчанию может являться?
значение переменной - Правильный ответ
константа
результат вызова функции
возможность указания значений полей по умолчанию в Python не предусмотрена

24.  Укажите результат выполнения скрипта и почему:
class Foo:
     count = x
     def __init__(self):
         self.count += 1

     def __del(self):
         self.count += 1


obj = Foo()
print(obj.count)

    --> NameError: name 'x' is not defined
    К count мы передаём значение х, которое мы нигде не объявили. Поэтому программа выдаст ошибку,
    что не находит значение х

25. Как указать в программе что класс A наследуется от B?
class A(B):
- наследование указывается в круглых скобках после названия класса




